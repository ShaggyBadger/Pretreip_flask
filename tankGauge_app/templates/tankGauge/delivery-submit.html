{% extends "base.html" %} {% block content %}

<!-- This is where the navigation menu is included. -->
{% include 'nav_menu.html' %}

<div class="container">
  <h1 class="text-center fw-bold display-4 mb-5">Tank Delivery Estimation</h1>
  <h5 class="text-center mb-5">{{ store_num }}</h5>

  <!-- This is the container where all the dynamically generated tank cards will be placed. -->
  <div id="tank-cards"></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  async function generate_chart(
    tank_id,
    containerId,
    startingInch,
    endingInch,
    csrfToken
  ) {
    try {
      // Fetch chart data (expects [{ inches: N, gallons: M }, ...])
      const resp = await fetch("/tankgauge/get-tank-chart-info", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": csrfToken,
        },
        body: JSON.stringify({ tank_id }),
      });
      if (!resp.ok) throw new Error("Network response was not ok");

      const chartData = await resp.json();

      // Build arrays (note keys: 'inches' and 'gallons')
      const inches = chartData.map((r) => Number(r.inches));
      const gallons = chartData.map((r) => Number(r.gallons));

      // Helper: find index closest to target (tolerance to avoid type/float issues)
      function findClosestIndex(arr, target) {
        if (target === null || target === undefined) return -1;
        let bestIdx = -1;
        let bestDiff = Infinity;
        for (let i = 0; i < arr.length; i++) {
          const diff = Math.abs(arr[i] - target);
          if (diff < bestDiff) {
            bestDiff = diff;
            bestIdx = i;
          }
        }
        // Accept it only if reasonably close (adjust tolerance if needed)
        return bestDiff <= 0.001 ? bestIdx : bestIdx;
      }

      const startIndex = findClosestIndex(inches, Number(startingInch));
      const endIndex = findClosestIndex(inches, Number(endingInch));
      console.log("startIndex, endIndex:", startIndex, endIndex);

      // Prepare chart container (only the chart div, don't wipe other result UI)
      const container = document.getElementById(containerId);
      if (!container)
        throw new Error("Chart container not found: " + containerId);
      container.innerHTML = ""; // ONLY clears chart area
      const canvas = document.createElement("canvas");
      container.appendChild(canvas);

      // Destroy previous chart instance if present (prevents duplicates / leaks)
      if (canvas._chartInstance) {
        canvas._chartInstance.destroy();
        canvas._chartInstance = null;
      }

      // Build datasets
      // Base line: full gray line, no points shown (pointRadius: 0)
      const baseDataset = {
        label: "Tank Curve",
        data: gallons.slice(), // full array
        borderColor: "#6c757d", // gray
        borderWidth: 2,
        fill: false,
        tension: 0.1,
        pointRadius: 0,
      };

      // Delivery segment: keep values only between startIndex..endIndex, null elsewhere
      const segmentData = gallons.map((g, i) =>
        startIndex >= 0 &&
        endIndex >= 0 &&
        i >= Math.min(startIndex, endIndex) &&
        i <= Math.max(startIndex, endIndex)
          ? g
          : null
      );

      const segmentDataset = {
        label: "Delivery Segment",
        data: segmentData,
        borderColor: "#28a745", // green
        borderWidth: 3,
        fill: false,
        tension: 0.1,
        pointRadius: 0,
      };

      // Start dot dataset (single point)
      const startDotData = gallons.map((g, i) => (i === startIndex ? g : null));
      const startDotDataset = {
        label: "Start",
        data: startDotData,
        borderColor: "#0d6efd",
        backgroundColor: "#0d6efd",
        pointRadius: startIndex >= 0 ? 6 : 0,
        showLine: false,
      };

      // End dot dataset (single point)
      const endDotData = gallons.map((g, i) => (i === endIndex ? g : null));
      const endDotDataset = {
        label: "End",
        data: endDotData,
        borderColor: "#dc3545",
        backgroundColor: "#dc3545",
        pointRadius: endIndex >= 0 ? 6 : 0,
        showLine: false,
      };

      const datasets = [
        baseDataset,
        segmentDataset,
        startDotDataset,
        endDotDataset,
      ];

      // Create Chart.js chart (use canvas.getContext)
      const ctx = canvas.getContext("2d");
      const chart = new Chart(ctx, {
        type: "line",
        data: {
          // labels are numeric inches (Chart.js will treat them as category labels)
          labels: inches,
          datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: "top" },
            title: { display: true, text: "Tank Gallons vs Inches" },
          },
          scales: {
            x: {
              title: { display: true, text: "Inches" },
            },
            y: {
              title: { display: true, text: "Gallons" },
            },
          },
        },
      });

      // attach instance to canvas so we can destroy it later
      canvas._chartInstance = chart;
    } catch (err) {
      console.error("Error generating chart:", err);
    }
  }
</script>

<script>
  // A. Pass the Python list of dictionaries 'tanks' directly to a JavaScript variable.
  // The default('[]') filter is added to prevent a JSON parsing error if 'tanks' is null or undefined.
  const tanks = JSON.parse(`{{ tanks | tojson | safe | default('[]') }}`);

  // B. Use Jinja to get the URL for the estimation endpoint. This is better than hardcoding.
  const estimateUrl = "{{ url_for('tankgauge.estimate_delivery_values') }}";

  /**
   * Dynamically renders tank cards based on the provided data.
   * @param {Array<Object>} tanks - A list of tank objects.
   */
  function renderTankCards(tanks) {
    const container = document.getElementById("tank-cards");
    const csrfToken = document
      .querySelector('meta[name="csrf-token"]')
      .getAttribute("content");

    // Clear any existing content before rendering
    container.innerHTML = "";

    tanks.forEach((tank, index) => {
      // C. Create the card element once. No need for a redundant inner div.
      const card = document.createElement("div");

      card.className = "card shadow-sm p-4 mb-4";

      card.innerHTML = `
      <!-- Row for displaying tank details -->
      <div class="row mb-3">
        <div class="col-12">
          <h5>Fuel Type: ${tank.fuel_type}</h5>
          <p class="mb-1">Max Capacity: ${tank.max_gal} gallons</p>
          <p>90% Capacity: ${tank.ninety_percent} gallons</p>
        </div>
      </div>

      <!-- Row for user input fields -->
      <div class="row mb-3">
          <div class="col-md-6 mb-3 mb-md-0">
              <label for="gallons-${index}" class="form-label">Enter delivery gallons:</label>
              <input type="number" id="gallons-${index}" class="form-control" placeholder="e.g. 4200">
          </div>
      </div>
      <div class="row mb-3">
          <div class="col-md-6">
              <label for="inches-${index}" class="form-label">Enter current inches:</label>
              <input type="number" id="inches-${index}" class="form-control" placeholder="e.g. 29">
          </div>
      </div>
      
      <!-- Row for the calculation button -->
      <div class="row mb-3">
          <div class="col-12">
              <button id="calc-btn-${index}" class="btn btn-primary mono w-100">Calculate</button>
          </div>
      </div>

      <!-- Container for displaying results or errors -->
      <div id="results-container-${index}" class="mt-4">
        <!-- Error messages will be displayed here -->
        <div id="error-message-${index}" class="text-danger fw-bold text-center"></div>

        <!-- This is the new, structured display for the successful results -->
        <div id="successful-results-${index}" class="mt-2" style="display: none;">
          <!-- Starting Gallons Row -->
          <div class="row mb-1">
            <div class="col-12">
              <span class="fw-bold me-2 text-info">Starting Gallons:</span>
              <span id="starting-gallons-value-${index}" class="text-info"></span>
            </div>
          </div>
          <!-- Starting Inches Row -->
          <div class="row mb-1">
            <div class="col-12">
              <span class="fw-bold me-2 text-info">Starting Inches:</span>
              <span id="starting-inches-value-${index}" class="text-info"></span>
            </div>
          </div>
          <!-- Ending Gallons Row -->
          <div class="row mt-3 mb-1">
            <div class="col-12">
              <span class="fw-bold me-2 text-success">Ending Gallons:</span>
              <span id="final-gallons-value-${index}" class="text-success"></span>
            </div>
          </div>
          <!-- Ending Inches Row -->
          <div class="row">
            <div class="col-12">
              <span class="fw-bold me-2 text-success">Ending Inches:</span>
              <span id="final-inches-value-${index}" class="text-success"></span>
            </div>
          </div>
          <div id="chart-container-${index}" class="mt-4"></div>
        </div>
      </div>
      `;

      container.appendChild(card);

      // E. Add the event listener for the button.
      document
        .getElementById(`calc-btn-${index}`)
        .addEventListener("click", function () {
          // Get the user's input values.
          const deliveryGallons = parseFloat(
            document.getElementById(`gallons-${index}`).value
          );
          const currentInches = parseFloat(
            document.getElementById(`inches-${index}`).value
          );

          const errorMessageElement = document.getElementById(
            `error-message-${index}`
          );
          const successfulResultsElement = document.getElementById(
            `successful-results-${index}`
          );
          const startingGallonsValueElement = document.getElementById(
            `starting-gallons-value-${index}`
          );
          const startingInchesValueElement = document.getElementById(
            `starting-inches-value-${index}`
          );
          const finalGallonsValueElement = document.getElementById(
            `final-gallons-value-${index}`
          );
          const finalInchesValueElement = document.getElementById(
            `final-inches-value-${index}`
          );

          // Clear previous results and errors
          errorMessageElement.textContent = "";
          successfulResultsElement.style.display = "none";

          // F. Validate inputs and provide in-page feedback.
          if (isNaN(deliveryGallons) || isNaN(currentInches)) {
            errorMessageElement.textContent = "Please enter valid numbers.";
            return;
          }

          errorMessageElement.textContent = "Calculating...";
          errorMessageElement.style.color = "#ffc107"; // Yellow for loading state

          // G. Send the data to Flask using the dynamically generated URL.
          fetch(estimateUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": csrfToken, // Flask-WTF looks for this
            },
            body: JSON.stringify({
              delivery_gallons: deliveryGallons,
              current_inches: currentInches,
              tank_type_id: tank.tank_type_id,
              max_gal: tank.max_gal,
            }),
          })
            .then((response) => response.json())
            .then((data) => {
              errorMessageElement.textContent = ""; // Clear loading message

              if (data.final_gallons !== null && data.final_inches !== null) {
                // H. Correctly display results in the new structured elements.
                startingGallonsValueElement.textContent = `${data.starting_gallons} gallons`;
                startingInchesValueElement.textContent = `${data.starting_inches}"`;
                finalGallonsValueElement.textContent = `${data.final_gallons} gallons`;
                finalInchesValueElement.textContent = `${data.final_inches}"`;
                successfulResultsElement.style.display = "block"; // Show the results container

                generate_chart(
                  tank.tank_type_id,
                  `chart-container-${index}`,
                  data.starting_inches,
                  data.final_inches,
                  csrfToken
                );
              } else {
                errorMessageElement.textContent =
                  data.message || `Calculation failed.`;
                errorMessageElement.style.color = "#dc3545"; // Red for error
              }
            })
            .catch((error) => {
              console.error("Error:", error);
              errorMessageElement.textContent =
                "An error occurred. Please try again.";
              errorMessageElement.style.color = "#dc3545"; // Red for error
            });
        });
    });
  }

  // Initial call to render the cards when the page loads.
  renderTankCards(tanks);
</script>

{% endblock %}
